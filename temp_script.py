from pathlib import Path

path = Path('yunet-core/tests/parity.rs')
text = path.read_text()
text = text.replace('use yunet_core::{DetectionOutput, InputSize, PostprocessConfig, YuNetDetector};', 'use yunet_core::{DetectionOutput, InputSize, PostprocessConfig, PreprocessConfig, YuNetDetector};')
old_new_call = '        let preprocess = PreprocessConfig { input_size };\n        let postprocess = PostprocessConfig {\n            score_threshold: fixture\n                .score_threshold\n                .unwrap_or(PostprocessConfig::default().score_threshold),\n            nms_threshold: fixture\n                .nms_threshold\n                .unwrap_or(PostprocessConfig::default().nms_threshold),\n            top_k: fixture\n                .top_k\n                .unwrap_or(PostprocessConfig::default().top_k),\n        };\n\n        let detector = YuNetDetector::new(model_path, preprocess.clone(), postprocess)?;\n        let output = detector.detect_path(image_rel)?;\n\n        assert_detections_close(&output, &fixture, 1e-2);\n'
new_new_call = '        let preprocess = PreprocessConfig { input_size };\n        let postprocess = PostprocessConfig {\n            score_threshold: fixture\n                .score_threshold\n                .unwrap_or(PostprocessConfig::default().score_threshold),\n            nms_threshold: fixture\n                .nms_threshold\n                .unwrap_or(PostprocessConfig::default().nms_threshold),\n            top_k: fixture\n                .top_k\n                .unwrap_or(PostprocessConfig::default().top_k),\n        };\n\n        let detector = YuNetDetector::new(model_path, preprocess, postprocess)?;\n        let output = detector.detect_path(image_rel)?;\n\n        assert_detections_close(&output, &fixture, 1e-2);\n'
if old_new_call not in text:
    raise SystemExit('expected call block not found')
text = text.replace(old_new_call, new_new_call)

old_assert = "fn assert_detections_close(actual: &DetectionOutput, expected: &FixtureFile, tol: f32) {\n    assert_eq!(\n        actual.detections.len(),\n        expected.detections.len(),\n        \"detection count mismatch\"\n    );\n\n    let mut actual_sorted = actual.detections.clone();\n    actual_sorted.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());\n    let mut expected_sorted = expected.detections.clone();\n    expected_sorted.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());\n\n    for (a, e) in actual_sorted.iter().zip(expected_sorted.iter()) {\n        assert!(\n            (a.score - e.score).abs() <= tol,\n            \"score mismatch: actual={}, expected={}\",\n            a.score,\n            e.score\n        );\n        for (idx, (av, ev)) in a.bbox.iter().zip(e.bbox.iter()).enumerate() {\n            assert!(\n                (av - ev).abs() <= tol,\n                \"bbox component {} mismatch: actual={}, expected={}\",\n                idx,\n                av,\n                ev\n            );\n        }\n        for (landmark_idx, (al, el)) in a.landmarks.iter().zip(e.landmarks.iter()).enumerate() {\n            for (coord_idx, (av, ev)) in al.iter().zip(el.iter()).enumerate() {\n                assert!(\n                    (av - ev).abs() <= tol,\n                    \"landmark {} coord {} mismatch: actual={}, expected={}\",\n                    landmark_idx,\n                    coord_idx,\n                    av,\n                    ev\n                );\n            }\n        }\n    }\n}\n"
new_assert = "fn assert_detections_close(actual: &DetectionOutput, expected: &FixtureFile, tol: f32) {\n    assert_eq!(\n        actual.detections.len(),\n        expected.detections.len(),\n        \"detection count mismatch\"\n    );\n\n    let mut actual_sorted = actual.detections.clone();\n    actual_sorted.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());\n    let mut expected_sorted = expected.detections.clone();\n    expected_sorted.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());\n\n    for (a, e) in actual_sorted.iter().zip(expected_sorted.iter()) {\n        assert!((a.score - e.score).abs() <= tol, \"score mismatch\");\n        let actual_bbox = [a.bbox.x, a.bbox.y, a.bbox.width, a.bbox.height];\n        for (idx, ev) in e.bbox.iter().enumerate() {\n            assert!((actual_bbox[idx] - ev).abs() <= tol, \"bbox mismatch\");\n        }\n        for (al, el) in a.landmarks.iter().zip(e.landmarks.iter()) {\n            let actual_lm = [al.x, al.y];\n            for coord_idx in 0..2 {\n                assert!((actual_lm[coord_idx] - el[coord_idx]).abs() <= tol, \"landmark mismatch\");\n            }\n        }\n    }\n}\n"
if old_assert not in text:
    raise SystemExit('old assert block not found')
text = text.replace(old_assert, new_assert)

path.write_text(text)
